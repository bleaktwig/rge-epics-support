/* Generated by re2c 2.0.3 on Fri May  6 16:39:25 2022 */
#line 1 "../snl.re"
/*************************************************************************\
Copyright (c) 2010-2012 Helmholtz-Zentrum Berlin f. Materialien
                        und Energie GmbH, Germany (HZB)
This file is distributed subject to a Software License Agreement found
in the file LICENSE that is included with this distribution.
\*************************************************************************/
/*************************************************************************\
                    Lexer specification/implementation
\*************************************************************************/
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "snl.h"
#include "main.h"
#include "parser.h"

#define	EOI		0

typedef unsigned char uchar;

#define	BSIZE	8192

#define	YYCTYPE			uchar
#define	YYCURSOR		cursor
#define	YYLIMIT			s->lim
#define	YYMARKER		s->ptr
#define	YYFILL(dummy)		cursor = fill(s, cursor);
#define	YYDEBUG(state, current) report("state = %d, current = %c\n", state, current);

#define	RET(i,r) {\
	s->cur = cursor;\
	t->str = r;\
	return i;\
}

#define OPERATOR		RET
#define LITERAL(t,e,n) 		RET(t,n)
#define KEYWORD 		RET
#define TYPEWORD		RET
#define IDENTIFIER(t,e,n)	RET(t,n)
#define DELIMITER		RET

#define DONE			RET(EOI,"")

typedef struct Scanner {
	uchar	*bot;	/* pointer to bottom (start) of buffer */
	uchar	*tok;	/* pointer to start of current token */
	uchar	*end;	/* pointer to (temporary) end of current token */
	uchar	*ptr;	/* marker for backtracking (always > tok) */
	uchar	*cur;	/* saved scan position between calls to scan() */
	uchar	*lim;	/* pointer to one position after last read char */
	uchar	*top;	/* pointer to (one after) top of allocated buffer */
	uchar	*eof;	/* pointer to (one after) last char in file (or 0) */
	const char *file;	/* source file name */
	int	line;	/* line number */
} Scanner;

static void scan_report(Scanner *s, const char *format, ...)
{
	va_list args;

	report_loc(s->file, s->line);
	va_start(args, format);
	fprintf(stderr, "lexical error: ");
	vfprintf(stderr, format, args);
	va_end(args);
}

/*
From the re2c docs:

   The generated code "calls" YYFILL(n) when the buffer needs (re)filling: at
   least n additional characters should be provided. YYFILL(n) should adjust
   YYCURSOR, YYLIMIT, YYMARKER and YYCTXMARKER as needed. Note that for typical
   programming languages n will be the length of the longest keyword plus one.

We also add a '\n' byte at the end of the file as sentinel.
*/
static uchar *fill(Scanner *s, uchar *cursor) {
	/* does not touch s->cur, instead works with argument cursor */
	if (!s->eof) {
		uint read_cnt;			/* number of bytes read */
		uint garbage = s->tok - s->bot;	/* number of garbage bytes */
		uint valid = s->lim - s->tok;	/* number of still valid bytes to copy */
		uchar *token = s->tok;		/* start of valid bytes */
		uint space = (s->top - s->lim) + garbage;
						/* remaining space after garbage collection */
		int need_alloc = space < BSIZE;	/* do we need to allocate a new buffer? */

		/* anything below s->tok is garbage, collect it */
		if (garbage) {
#ifdef DEBUG
			report("fill: garbage=%u, need_alloc=%d\n", garbage, need_alloc);
#endif
			if (!need_alloc) {
				/* shift valid buffer content down to bottom of buffer */
				memmove(s->bot, token, valid);
			}
			/* adjust pointers */
			s->tok = s->bot;	/* same as s->tok -= garbage */
			s->ptr -= garbage;
			cursor -= garbage;
			s->lim -= garbage;
			s->end -= garbage;
			/* invariant: s->bot, s->top, s->eof, s->lim - s->tok */
		}
		/* increase the buffer size if necessary, ensuring that we have
		   at least BSIZE bytes of free space to fill (after s->lim) */
		if (need_alloc) {
			uchar *buf = (uchar*) malloc((s->lim - s->bot + BSIZE)*sizeof(uchar));
#ifdef DEBUG
			report("fill: need_alloc, bot: before=%p after=%p\n", s->bot, buf);
#endif
			memcpy(buf, token, valid);
			s->tok = buf;
			s->end = &buf[s->end - s->bot];
			s->ptr = &buf[s->ptr - s->bot];
			cursor = &buf[cursor - s->bot];
			s->lim = &buf[s->lim - s->bot];
			s->top = s->lim + BSIZE;
			free(s->bot);
			s->bot = buf;
		}
		/* fill the buffer, starting at s->lim, by reading a chunk of
		   BSIZE bytes (or less if eof is encountered) */
		if ((read_cnt = fread(s->lim, sizeof(uchar), BSIZE, stdin)) != BSIZE) {
			if (ferror(stdin)) {
				perror("error reading input");
				exit(EXIT_FAILURE);
			}
			if (feof(stdin)) {
				s->eof = &s->lim[read_cnt];
				/* insert sentinel and increase s->eof */
				*(s->eof)++ = '\n';
			}
		}
		s->lim += read_cnt;	/* adjust limit */
	}
	return cursor;
}

/* alias strdup_from_to: duplicate string from start to (exclusive) stop */
static char *strdupft(uchar *start, uchar *stop) {
	char *result;
	size_t n;
	assert (stop - start >= 0);
	n = (size_t)(stop - start);
	result = malloc(n+1);
	memcpy(result, start, n);
	result[n] = 0;
	return result;
}

/*
 * Note: Linemarkers differ between compilers. The MS C preprocessor outputs
 * "#line <linenum> <filename>" directives, while gcc leaves off the "line".
 */

#line 175 "../snl.re"


static int scan(Scanner *s, Token *t) {
	uchar *cursor = s->cur;
	int in_c_code = 0;
	/*
	Note: Must use a temporary offset for (parts of) line_marker.
	Normally we use s->tok to remember start positions. But line_markers
	can appear nested inside c_code block tokens, so using s->tok for
	line_markers would destroy them.
	*/
	int line_marker_part = 0;

	s->end = 0;

snl:
	if (in_c_code)
		goto c_code;
	t->line = s->line;
	t->file = s->file;
	s->tok = cursor;


#line 189 "lexer.c"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  38,   0,  36,  36,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 38,  32,  32,  32,  32,  32,  32,   0, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		184, 184, 184, 184, 184, 184, 184, 184, 
		184, 184,  32,  32,  32,  32,  32,  32, 
		 32, 176, 176, 176, 176, 176, 176,  48, 
		 48,  48,  48,  48, 112,  48,  48,  48, 
		 48,  48,  48,  48,  48, 112,  48,  48, 
		 48,  48,  48,  32,   0,  32,  32,  48, 
		 32, 176, 176, 176, 176, 176, 176,  48, 
		 48,  48,  48,  48, 112,  48,  48,  48, 
		 48,  48,  48,  48,  48, 112,  48,  48, 
		 48,  48,  48,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
		 32,  32,  32,  32,  32,  32,  32,  32, 
	};
	if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 2) {
		goto yy4;
	}
	switch (yych) {
	case '\t':
	case '\n':	goto yy7;
	case '\v':
	case '\f':	goto yy9;
	case ' ':
	case '!':	goto yy11;
	case '"':	goto yy13;
	case '#':	goto yy15;
	case '%':	goto yy16;
	case '&':	goto yy18;
	case '\'':	goto yy20;
	case '(':	goto yy21;
	case ')':	goto yy23;
	case '*':	goto yy25;
	case '+':	goto yy27;
	case ',':	goto yy29;
	case '-':	goto yy31;
	case '.':	goto yy33;
	case '/':	goto yy35;
	case '0':	goto yy37;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy39;
	case ':':	goto yy41;
	case ';':	goto yy43;
	case '<':	goto yy45;
	case '=':	goto yy47;
	case '>':	goto yy49;
	case '?':	goto yy51;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'g':
	case 'h':
	case 'j':
	case 'k':
	case 'n':
	case 'q':
	case 'r':
	case 'v':
	case 'x':
	case 'y':
	case 'z':	goto yy53;
	case '[':	goto yy56;
	case ']':	goto yy58;
	case '^':	goto yy60;
	case 'a':	goto yy62;
	case 'b':	goto yy63;
	case 'c':	goto yy64;
	case 'd':	goto yy65;
	case 'e':	goto yy66;
	case 'f':	goto yy67;
	case 'i':	goto yy68;
	case 'l':	goto yy69;
	case 'm':	goto yy70;
	case 'o':	goto yy71;
	case 'p':	goto yy72;
	case 's':	goto yy73;
	case 't':	goto yy74;
	case 'u':	goto yy75;
	case 'w':	goto yy76;
	case '{':	goto yy77;
	case '|':	goto yy79;
	case '}':	goto yy81;
	case '~':	goto yy83;
	default:	goto yy2;
	}
yy2:
	++YYCURSOR;
yy3:
#line 315 "../snl.re"
	{ scan_report(s, "invalid character\n"); DONE; }
#line 335 "lexer.c"
yy4:
	yyaccept = 0;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 6) YYFILL(6);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 2) {
		goto yy4;
	}
	if (yych <= '\n') goto yy6;
	if (yych <= '\f') goto yy9;
	if (yych == '#') goto yy85;
yy6:
#line 314 "../snl.re"
	{ goto snl; }
#line 350 "lexer.c"
yy7:
	++YYCURSOR;
#line 198 "../snl.re"
	{
				if(cursor == s->eof) DONE;
				s->line++;
				goto snl;
			}
#line 359 "lexer.c"
yy9:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 4) {
		goto yy9;
	}
	goto yy6;
yy11:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy87;
#line 302 "../snl.re"
	{ OPERATOR(NOT,		"!"); }
#line 373 "lexer.c"
yy13:
	++YYCURSOR;
#line 207 "../snl.re"
	{
				s->tok = s->end = cursor;
				goto string_const;
			}
#line 381 "lexer.c"
yy15:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy89;
		goto yy3;
	} else {
		if (yych <= ' ') goto yy89;
		if (yych == 'l') goto yy92;
		goto yy3;
	}
yy16:
	yych = *++YYCURSOR;
	if (yych <= '<') {
		if (yych == '%') goto yy93;
	} else {
		if (yych <= '=') goto yy96;
		if (yych == '{') goto yy98;
	}
#line 308 "../snl.re"
	{ OPERATOR(MOD,		"%"); }
#line 403 "lexer.c"
yy18:
	yych = *++YYCURSOR;
	if (yych == '&') goto yy100;
	if (yych == '=') goto yy102;
#line 301 "../snl.re"
	{ OPERATOR(AMPERSAND,	"&"); }
#line 410 "lexer.c"
yy20:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '\n') goto yy3;
	goto yy105;
yy21:
	++YYCURSOR;
#line 296 "../snl.re"
	{ DELIMITER(LPAREN,	"("); }
#line 420 "lexer.c"
yy23:
	++YYCURSOR;
#line 297 "../snl.re"
	{ DELIMITER(RPAREN,	")"); }
#line 425 "lexer.c"
yy25:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy108;
#line 306 "../snl.re"
	{ OPERATOR(ASTERISK,	"*"); }
#line 431 "lexer.c"
yy27:
	yych = *++YYCURSOR;
	if (yych == '+') goto yy110;
	if (yych == '=') goto yy112;
#line 305 "../snl.re"
	{ OPERATOR(ADD,		"+"); }
#line 438 "lexer.c"
yy29:
	++YYCURSOR;
#line 293 "../snl.re"
	{ DELIMITER(COMMA,	","); }
#line 443 "lexer.c"
yy31:
	yych = *++YYCURSOR;
	if (yych <= '<') {
		if (yych == '-') goto yy114;
	} else {
		if (yych <= '=') goto yy116;
		if (yych <= '>') goto yy118;
	}
#line 304 "../snl.re"
	{ OPERATOR(SUB,		"-"); }
#line 454 "lexer.c"
yy33:
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy34;
	if (yych <= '9') goto yy120;
yy34:
#line 300 "../snl.re"
	{ OPERATOR(PERIOD,	"."); }
#line 462 "lexer.c"
yy35:
	yych = *++YYCURSOR;
	if (yych == '*') goto yy123;
	if (yych == '=') goto yy125;
#line 307 "../snl.re"
	{ OPERATOR(SLASH,	"/"); }
#line 469 "lexer.c"
yy37:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'X') goto yy130;
	if (yych == 'x') goto yy130;
	goto yy40;
yy38:
#line 264 "../snl.re"
	{ LITERAL(INTCON, integer_literal, strdupft(s->tok, cursor)); }
#line 479 "lexer.c"
yy39:
	yyaccept = 2;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
yy40:
	if (yybm[0+yych] & 8) {
		goto yy39;
	}
	if (yych <= 'T') {
		if (yych <= 'D') {
			if (yych == '.') goto yy120;
			goto yy38;
		} else {
			if (yych <= 'E') goto yy127;
			if (yych == 'L') goto yy128;
			goto yy38;
		}
	} else {
		if (yych <= 'k') {
			if (yych <= 'U') goto yy128;
			if (yych == 'e') goto yy127;
			goto yy38;
		} else {
			if (yych <= 'l') goto yy128;
			if (yych == 'u') goto yy128;
			goto yy38;
		}
	}
yy41:
	++YYCURSOR;
#line 294 "../snl.re"
	{ OPERATOR(COLON,	":"); }
#line 513 "lexer.c"
yy43:
	++YYCURSOR;
#line 290 "../snl.re"
	{ DELIMITER(SEMICOLON,	";"); }
#line 518 "lexer.c"
yy45:
	yych = *++YYCURSOR;
	if (yych <= ';') goto yy46;
	if (yych <= '<') goto yy131;
	if (yych <= '=') goto yy133;
yy46:
#line 309 "../snl.re"
	{ OPERATOR(LT,		"<"); }
#line 527 "lexer.c"
yy47:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy135;
#line 295 "../snl.re"
	{ OPERATOR(EQUAL,	"="); }
#line 533 "lexer.c"
yy49:
	yych = *++YYCURSOR;
	if (yych <= '<') goto yy50;
	if (yych <= '=') goto yy137;
	if (yych <= '>') goto yy139;
yy50:
#line 310 "../snl.re"
	{ OPERATOR(GT,		">"); }
#line 542 "lexer.c"
yy51:
	++YYCURSOR;
#line 313 "../snl.re"
	{ OPERATOR(QUESTION,	"?"); }
#line 547 "lexer.c"
yy53:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy54:
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 262 "../snl.re"
	{ IDENTIFIER(NAME, identifier, strdupft(s->tok, cursor)); }
#line 558 "lexer.c"
yy56:
	++YYCURSOR;
#line 298 "../snl.re"
	{ DELIMITER(LBRACKET,	"["); }
#line 563 "lexer.c"
yy58:
	++YYCURSOR;
#line 299 "../snl.re"
	{ DELIMITER(RBRACKET,	"]"); }
#line 568 "lexer.c"
yy60:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy141;
#line 311 "../snl.re"
	{ OPERATOR(CARET,	"^"); }
#line 574 "lexer.c"
yy62:
	yych = *++YYCURSOR;
	if (yych == 's') goto yy143;
	goto yy54;
yy63:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy144;
	goto yy54;
yy64:
	yych = *++YYCURSOR;
	if (yych == 'h') goto yy145;
	if (yych == 'o') goto yy146;
	goto yy54;
yy65:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy147;
	goto yy54;
yy66:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l':	goto yy148;
	case 'n':	goto yy149;
	case 'v':	goto yy150;
	case 'x':	goto yy151;
	default:	goto yy54;
	}
yy67:
	yych = *++YYCURSOR;
	if (yych == 'l') goto yy152;
	if (yych == 'o') goto yy153;
	goto yy54;
yy68:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy154;
	if (yych == 'n') goto yy156;
	goto yy54;
yy69:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy157;
	goto yy54;
yy70:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy158;
	goto yy54;
yy71:
	yych = *++YYCURSOR;
	if (yych == 'p') goto yy159;
	goto yy54;
yy72:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy160;
	goto yy54;
yy73:
	yych = *++YYCURSOR;
	if (yych <= 's') {
		if (yych == 'h') goto yy161;
		if (yych <= 'r') goto yy54;
		goto yy162;
	} else {
		if (yych <= 't') goto yy164;
		if (yych == 'y') goto yy165;
		goto yy54;
	}
yy74:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy166;
	goto yy54;
yy75:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy168;
	if (yych == 'n') goto yy169;
	goto yy54;
yy76:
	yych = *++YYCURSOR;
	if (yych == 'h') goto yy170;
	goto yy54;
yy77:
	++YYCURSOR;
#line 291 "../snl.re"
	{ DELIMITER(LBRACE,	"{"); }
#line 655 "lexer.c"
yy79:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy171;
	if (yych == '|') goto yy173;
#line 312 "../snl.re"
	{ OPERATOR(VBAR,	"|"); }
#line 662 "lexer.c"
yy81:
	++YYCURSOR;
#line 292 "../snl.re"
	{ DELIMITER(RBRACE,	"}"); }
#line 667 "lexer.c"
yy83:
	++YYCURSOR;
#line 303 "../snl.re"
	{ OPERATOR(TILDE,	"~"); }
#line 672 "lexer.c"
yy85:
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy89;
	} else {
		if (yych <= ' ') goto yy89;
		if (yych == 'l') goto yy92;
	}
yy86:
	YYCURSOR = YYMARKER;
	if (yyaccept <= 2) {
		if (yyaccept <= 1) {
			if (yyaccept == 0) {
				goto yy6;
			} else {
				goto yy3;
			}
		} else {
			goto yy38;
		}
	} else {
		if (yyaccept == 3) {
			goto yy91;
		} else {
			goto yy122;
		}
	}
yy87:
	++YYCURSOR;
#line 289 "../snl.re"
	{ OPERATOR(NE,		"!="); }
#line 704 "lexer.c"
yy89:
	yyaccept = 3;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy89;
	} else {
		if (yych <= ' ') goto yy89;
		if (yych == 'l') goto yy92;
	}
yy91:
#line 203 "../snl.re"
	{
				line_marker_part = cursor - s->tok;
				goto line_marker;
			}
#line 722 "lexer.c"
yy92:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy175;
	goto yy86;
yy93:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych == '\t') goto yy93;
	if (yych == ' ') goto yy93;
#line 220 "../snl.re"
	{
				s->tok = s->end = cursor;
				goto c_code_line;
			}
#line 738 "lexer.c"
yy96:
	++YYCURSOR;
#line 275 "../snl.re"
	{ OPERATOR(MODEQ,	"%="); }
#line 743 "lexer.c"
yy98:
	++YYCURSOR;
#line 212 "../snl.re"
	{
				s->tok = cursor;
				in_c_code = 1;
#ifdef DEBUG
				report("in_c_code: cursor=%p, tok=%p\n", cursor, s->tok);
#endif
				goto c_code;
			}
#line 755 "lexer.c"
yy100:
	++YYCURSOR;
#line 284 "../snl.re"
	{ OPERATOR(ANDAND,	"&&"); }
#line 760 "lexer.c"
yy102:
	++YYCURSOR;
#line 276 "../snl.re"
	{ OPERATOR(ANDEQ,	"&="); }
#line 765 "lexer.c"
yy104:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy105:
	if (yybm[0+yych] & 32) {
		goto yy104;
	}
	if (yych <= '\n') goto yy86;
	if (yych >= '(') goto yy107;
	++YYCURSOR;
	goto yy38;
yy107:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'b') {
		if (yych <= '7') {
			if (yych <= '&') {
				if (yych == '"') goto yy104;
				goto yy86;
			} else {
				if (yych <= '\'') goto yy104;
				if (yych <= '/') goto yy86;
				goto yy104;
			}
		} else {
			if (yych <= '[') {
				if (yych == '?') goto yy104;
				goto yy86;
			} else {
				if (yych <= '\\') goto yy104;
				if (yych <= '`') goto yy86;
				goto yy104;
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'm') {
				if (yych == 'f') goto yy104;
				goto yy86;
			} else {
				if (yych <= 'n') goto yy104;
				if (yych <= 'q') goto yy86;
				goto yy104;
			}
		} else {
			if (yych <= 'u') {
				if (yych == 't') goto yy104;
				goto yy86;
			} else {
				if (yych <= 'v') goto yy104;
				if (yych == 'x') goto yy176;
				goto yy86;
			}
		}
	}
yy108:
	++YYCURSOR;
#line 273 "../snl.re"
	{ OPERATOR(MULEQ,	"*="); }
#line 827 "lexer.c"
yy110:
	++YYCURSOR;
#line 281 "../snl.re"
	{ OPERATOR(INCR,	"++"); }
#line 832 "lexer.c"
yy112:
	++YYCURSOR;
#line 271 "../snl.re"
	{ OPERATOR(ADDEQ,	"+="); }
#line 837 "lexer.c"
yy114:
	++YYCURSOR;
#line 282 "../snl.re"
	{ OPERATOR(DECR,	"--"); }
#line 842 "lexer.c"
yy116:
	++YYCURSOR;
#line 272 "../snl.re"
	{ OPERATOR(SUBEQ,	"-="); }
#line 847 "lexer.c"
yy118:
	++YYCURSOR;
#line 283 "../snl.re"
	{ OPERATOR(POINTER,	"->"); }
#line 852 "lexer.c"
yy120:
	yyaccept = 4;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	if (yych <= 'K') {
		if (yych <= 'D') {
			if (yych <= '/') goto yy122;
			if (yych <= '9') goto yy120;
		} else {
			if (yych <= 'E') goto yy127;
			if (yych <= 'F') goto yy177;
		}
	} else {
		if (yych <= 'e') {
			if (yych <= 'L') goto yy177;
			if (yych >= 'e') goto yy127;
		} else {
			if (yych <= 'f') goto yy177;
			if (yych == 'l') goto yy177;
		}
	}
yy122:
#line 267 "../snl.re"
	{ LITERAL(FPCON, floating_point_literal, strdupft(s->tok, cursor)); }
#line 878 "lexer.c"
yy123:
	++YYCURSOR;
#line 211 "../snl.re"
	{ goto comment; }
#line 883 "lexer.c"
yy125:
	++YYCURSOR;
#line 274 "../snl.re"
	{ OPERATOR(DIVEQ,	"/="); }
#line 888 "lexer.c"
yy127:
	yych = *++YYCURSOR;
	if (yych <= ',') {
		if (yych == '+') goto yy178;
		goto yy86;
	} else {
		if (yych <= '-') goto yy178;
		if (yych <= '/') goto yy86;
		if (yych <= '9') goto yy179;
		goto yy86;
	}
yy128:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 64) {
		goto yy128;
	}
	goto yy38;
yy130:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy181;
	}
	goto yy86;
yy131:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy183;
#line 280 "../snl.re"
	{ OPERATOR(LSHIFT,	"<<"); }
#line 919 "lexer.c"
yy133:
	++YYCURSOR;
#line 286 "../snl.re"
	{ OPERATOR(LE,		"<="); }
#line 924 "lexer.c"
yy135:
	++YYCURSOR;
#line 288 "../snl.re"
	{ OPERATOR(EQ,		"=="); }
#line 929 "lexer.c"
yy137:
	++YYCURSOR;
#line 287 "../snl.re"
	{ OPERATOR(GE,		">="); }
#line 934 "lexer.c"
yy139:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy185;
#line 279 "../snl.re"
	{ OPERATOR(RSHIFT,	">>"); }
#line 940 "lexer.c"
yy141:
	++YYCURSOR;
#line 277 "../snl.re"
	{ OPERATOR(XOREQ,	"^="); }
#line 945 "lexer.c"
yy143:
	yych = *++YYCURSOR;
	if (yych == 's') goto yy187;
	goto yy54;
yy144:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy188;
	goto yy54;
yy145:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy189;
	goto yy54;
yy146:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy190;
	goto yy54;
yy147:
	yych = *++YYCURSOR;
	if (yych == 'u') goto yy191;
	goto yy54;
yy148:
	yych = *++YYCURSOR;
	if (yych == 's') goto yy192;
	goto yy54;
yy149:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy193;
	goto yy54;
yy150:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy194;
	goto yy54;
yy151:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy195;
	goto yy54;
yy152:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy196;
	goto yy54;
yy153:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy197;
	goto yy54;
yy154:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 237 "../snl.re"
	{ KEYWORD(IF,		"if"); }
#line 997 "lexer.c"
yy156:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy199;
	goto yy54;
yy157:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy201;
	goto yy54;
yy158:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy202;
	goto yy54;
yy159:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy203;
	goto yy54;
yy160:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy204;
	goto yy54;
yy161:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy205;
	goto yy54;
yy162:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 244 "../snl.re"
	{ KEYWORD(SS,		"ss"); }
#line 1029 "lexer.c"
yy164:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy206;
	if (yych == 'r') goto yy207;
	goto yy54;
yy165:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy208;
	goto yy54;
yy166:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 250 "../snl.re"
	{ KEYWORD(TO,		"to"); }
#line 1046 "lexer.c"
yy168:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy209;
	goto yy54;
yy169:
	yych = *++YYCURSOR;
	if (yych == 's') goto yy210;
	goto yy54;
yy170:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy211;
	if (yych == 'i') goto yy212;
	goto yy54;
yy171:
	++YYCURSOR;
#line 278 "../snl.re"
	{ OPERATOR(OREQ,	"|="); }
#line 1064 "lexer.c"
yy173:
	++YYCURSOR;
#line 285 "../snl.re"
	{ OPERATOR(OROR,	"||"); }
#line 1069 "lexer.c"
yy175:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy213;
	goto yy86;
yy176:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy86;
		if (yych <= '9') goto yy104;
		goto yy86;
	} else {
		if (yych <= 'F') goto yy104;
		if (yych <= '`') goto yy86;
		if (yych <= 'f') goto yy104;
		goto yy86;
	}
yy177:
	++YYCURSOR;
	goto yy122;
yy178:
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy86;
	if (yych >= ':') goto yy86;
yy179:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'K') {
		if (yych <= '9') {
			if (yych <= '/') goto yy122;
			goto yy179;
		} else {
			if (yych == 'F') goto yy177;
			goto yy122;
		}
	} else {
		if (yych <= 'f') {
			if (yych <= 'L') goto yy177;
			if (yych <= 'e') goto yy122;
			goto yy177;
		} else {
			if (yych == 'l') goto yy177;
			goto yy122;
		}
	}
yy181:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy181;
	}
	if (yych <= 'U') {
		if (yych == 'L') goto yy128;
		if (yych <= 'T') goto yy38;
		goto yy128;
	} else {
		if (yych <= 'l') {
			if (yych <= 'k') goto yy38;
			goto yy128;
		} else {
			if (yych == 'u') goto yy128;
			goto yy38;
		}
	}
yy183:
	++YYCURSOR;
#line 270 "../snl.re"
	{ OPERATOR(LSHEQ,	"<<="); }
#line 1141 "lexer.c"
yy185:
	++YYCURSOR;
#line 269 "../snl.re"
	{ OPERATOR(RSHEQ,	">>="); }
#line 1146 "lexer.c"
yy187:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy214;
	goto yy54;
yy188:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy215;
	goto yy54;
yy189:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy216;
	goto yy54;
yy190:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy218;
	if (yych == 't') goto yy219;
	goto yy54;
yy191:
	yych = *++YYCURSOR;
	if (yych == 'b') goto yy220;
	goto yy54;
yy192:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy221;
	goto yy54;
yy193:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy223;
	goto yy54;
yy194:
	yych = *++YYCURSOR;
	if (yych == 'l') goto yy224;
	goto yy54;
yy195:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy225;
	goto yy54;
yy196:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy227;
	goto yy54;
yy197:
	yych = *++YYCURSOR;
	if (yych <= '^') {
		if (yych <= '9') {
			if (yych >= '0') goto yy53;
		} else {
			if (yych <= '@') goto yy198;
			if (yych <= 'Z') goto yy53;
		}
	} else {
		if (yych <= 'd') {
			if (yych != '`') goto yy53;
		} else {
			if (yych <= 'e') goto yy228;
			if (yych <= 'z') goto yy53;
		}
	}
yy198:
#line 235 "../snl.re"
	{ KEYWORD(FOR,		"for"); }
#line 1208 "lexer.c"
yy199:
	yych = *++YYCURSOR;
	if (yych <= '8') {
		if (yych <= '1') {
			if (yych <= '/') goto yy200;
			if (yych <= '0') goto yy53;
			goto yy229;
		} else {
			if (yych == '3') goto yy230;
			if (yych <= '7') goto yy53;
			goto yy231;
		}
	} else {
		if (yych <= '^') {
			if (yych <= '9') goto yy53;
			if (yych <= '@') goto yy200;
			if (yych <= 'Z') goto yy53;
		} else {
			if (yych == '`') goto yy200;
			if (yych <= 'z') goto yy53;
		}
	}
yy200:
#line 238 "../snl.re"
	{ TYPEWORD(INT,		"int"); }
#line 1234 "lexer.c"
yy201:
	yych = *++YYCURSOR;
	if (yych == 'g') goto yy232;
	goto yy54;
yy202:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy234;
	goto yy54;
yy203:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy235;
	goto yy54;
yy204:
	yych = *++YYCURSOR;
	if (yych == 'g') goto yy236;
	goto yy54;
yy205:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy237;
	goto yy54;
yy206:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy238;
	goto yy54;
yy207:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy239;
	goto yy54;
yy208:
	yych = *++YYCURSOR;
	if (yych == 'c') goto yy240;
	goto yy54;
yy209:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy242;
	goto yy54;
yy210:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy243;
	goto yy54;
yy211:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy244;
	goto yy54;
yy212:
	yych = *++YYCURSOR;
	if (yych == 'l') goto yy246;
	goto yy54;
yy213:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy247;
	goto yy86;
yy214:
	yych = *++YYCURSOR;
	if (yych == 'g') goto yy248;
	goto yy54;
yy215:
	yych = *++YYCURSOR;
	if (yych == 'k') goto yy249;
	goto yy54;
yy216:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 226 "../snl.re"
	{ TYPEWORD(CHAR,	"char"); }
#line 1302 "lexer.c"
yy218:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy251;
	goto yy54;
yy219:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy252;
	goto yy54;
yy220:
	yych = *++YYCURSOR;
	if (yych == 'l') goto yy253;
	goto yy54;
yy221:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 230 "../snl.re"
	{ KEYWORD(ELSE,		"else"); }
#line 1322 "lexer.c"
yy223:
	yych = *++YYCURSOR;
	if (yych == 'y') goto yy254;
	goto yy54;
yy224:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy256;
	goto yy54;
yy225:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 233 "../snl.re"
	{ KEYWORD(EXIT,		"exit"); }
#line 1338 "lexer.c"
yy227:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy257;
	goto yy54;
yy228:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy259;
	goto yy54;
yy229:
	yych = *++YYCURSOR;
	if (yych == '6') goto yy260;
	goto yy54;
yy230:
	yych = *++YYCURSOR;
	if (yych == '2') goto yy261;
	goto yy54;
yy231:
	yych = *++YYCURSOR;
	if (yych == '_') goto yy262;
	goto yy54;
yy232:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 239 "../snl.re"
	{ TYPEWORD(LONG,	"long"); }
#line 1366 "lexer.c"
yy234:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy263;
	goto yy54;
yy235:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy264;
	goto yy54;
yy236:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy265;
	goto yy54;
yy237:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy266;
	goto yy54;
yy238:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy268;
	goto yy54;
yy239:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy270;
	goto yy54;
yy240:
	yych = *++YYCURSOR;
	if (yych <= 'Z') {
		if (yych <= '@') {
			if (yych <= '/') goto yy241;
			if (yych <= '9') goto yy53;
		} else {
			if (yych == 'Q') goto yy271;
			goto yy53;
		}
	} else {
		if (yych <= '`') {
			if (yych == '_') goto yy53;
		} else {
			if (yych == 'q') goto yy273;
			if (yych <= 'z') goto yy53;
		}
	}
yy241:
#line 249 "../snl.re"
	{ KEYWORD(SYNC,		"sync"); }
#line 1412 "lexer.c"
yy242:
	yych = *++YYCURSOR;
	if (yych <= '2') {
		if (yych == '1') goto yy275;
		goto yy54;
	} else {
		if (yych <= '3') goto yy276;
		if (yych == '8') goto yy277;
		goto yy54;
	}
yy243:
	yych = *++YYCURSOR;
	if (yych == 'g') goto yy278;
	goto yy54;
yy244:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 252 "../snl.re"
	{ KEYWORD(WHEN,		"when"); }
#line 1434 "lexer.c"
yy246:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy279;
	goto yy54;
yy247:
	yych = *++YYCURSOR;
	if (yych == '\t') goto yy281;
	if (yych == ' ') goto yy281;
	goto yy86;
yy248:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy283;
	goto yy54;
yy249:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 225 "../snl.re"
	{ KEYWORD(BREAK,	"break"); }
#line 1455 "lexer.c"
yy251:
	yych = *++YYCURSOR;
	if (yych == 'c') goto yy285;
	goto yy54;
yy252:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy286;
	goto yy54;
yy253:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy287;
	goto yy54;
yy254:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 231 "../snl.re"
	{ KEYWORD(ENTRY,	"entry"); }
#line 1475 "lexer.c"
yy256:
	yych = *++YYCURSOR;
	if (yych == 'g') goto yy289;
	goto yy54;
yy257:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 234 "../snl.re"
	{ TYPEWORD(FLOAT,	"float"); }
#line 1487 "lexer.c"
yy259:
	yych = *++YYCURSOR;
	if (yych == 'g') goto yy291;
	goto yy54;
yy260:
	yych = *++YYCURSOR;
	if (yych == '_') goto yy292;
	goto yy54;
yy261:
	yych = *++YYCURSOR;
	if (yych == '_') goto yy293;
	goto yy54;
yy262:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy294;
	goto yy54;
yy263:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy296;
	goto yy54;
yy264:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy297;
	goto yy54;
yy265:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy299;
	goto yy54;
yy266:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 243 "../snl.re"
	{ TYPEWORD(SHORT,	"short"); }
#line 1523 "lexer.c"
yy268:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 245 "../snl.re"
	{ KEYWORD(STATE,	"state"); }
#line 1531 "lexer.c"
yy270:
	yych = *++YYCURSOR;
	if (yych == 'g') goto yy300;
	goto yy54;
yy271:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 247 "../snl.re"
	{ KEYWORD(SYNCQ,	"syncQ"); }
#line 1543 "lexer.c"
yy273:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 248 "../snl.re"
	{ KEYWORD(SYNCQ,	"syncq"); }
#line 1551 "lexer.c"
yy275:
	yych = *++YYCURSOR;
	if (yych == '6') goto yy302;
	goto yy54;
yy276:
	yych = *++YYCURSOR;
	if (yych == '2') goto yy303;
	goto yy54;
yy277:
	yych = *++YYCURSOR;
	if (yych == '_') goto yy304;
	goto yy54;
yy278:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy305;
	goto yy54;
yy279:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 253 "../snl.re"
	{ KEYWORD(WHILE,	"while"); }
#line 1575 "lexer.c"
yy281:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych == '\t') goto yy281;
	if (yych == ' ') goto yy281;
	goto yy91;
yy283:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 224 "../snl.re"
	{ KEYWORD(ASSIGN,	"assign"); }
#line 1590 "lexer.c"
yy285:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy306;
	goto yy54;
yy286:
	yych = *++YYCURSOR;
	if (yych == 'u') goto yy308;
	goto yy54;
yy287:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 229 "../snl.re"
	{ TYPEWORD(DOUBLE,	"double"); }
#line 1606 "lexer.c"
yy289:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 232 "../snl.re"
	{ TYPEWORD(EVFLAG,	"evflag"); }
#line 1614 "lexer.c"
yy291:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy309;
	goto yy54;
yy292:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy311;
	goto yy54;
yy293:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy313;
	goto yy54;
yy294:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 255 "../snl.re"
	{ TYPEWORD(INT8T,  	"int8_t"); }
#line 1634 "lexer.c"
yy296:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy315;
	goto yy54;
yy297:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 241 "../snl.re"
	{ KEYWORD(OPTION,	"option"); }
#line 1646 "lexer.c"
yy299:
	yych = *++YYCURSOR;
	if (yych == 'm') goto yy317;
	goto yy54;
yy300:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 246 "../snl.re"
	{ KEYWORD(STRING,	"string"); }
#line 1658 "lexer.c"
yy302:
	yych = *++YYCURSOR;
	if (yych == '_') goto yy319;
	goto yy54;
yy303:
	yych = *++YYCURSOR;
	if (yych == '_') goto yy320;
	goto yy54;
yy304:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy321;
	goto yy54;
yy305:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy323;
	goto yy54;
yy306:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 227 "../snl.re"
	{ KEYWORD(CONNECT,	"connect"); }
#line 1682 "lexer.c"
yy308:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy324;
	goto yy54;
yy309:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 236 "../snl.re"
	{ TYPEWORD(FOREIGN,	"foreign"); }
#line 1694 "lexer.c"
yy311:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 257 "../snl.re"
	{ TYPEWORD(INT16T, 	"int16_t"); }
#line 1702 "lexer.c"
yy313:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 259 "../snl.re"
	{ TYPEWORD(INT32T, 	"int32_t"); }
#line 1710 "lexer.c"
yy315:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 240 "../snl.re"
	{ KEYWORD(MONITOR,	"monitor"); }
#line 1718 "lexer.c"
yy317:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 242 "../snl.re"
	{ KEYWORD(PROGRAM,	"program"); }
#line 1726 "lexer.c"
yy319:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy326;
	goto yy54;
yy320:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy328;
	goto yy54;
yy321:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 256 "../snl.re"
	{ TYPEWORD(UINT8T, 	"uint8_t"); }
#line 1742 "lexer.c"
yy323:
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy330;
	goto yy54;
yy324:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 228 "../snl.re"
	{ KEYWORD(CONTINUE,	"continue"); }
#line 1754 "lexer.c"
yy326:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 258 "../snl.re"
	{ TYPEWORD(UINT16T,	"uint16_t"); }
#line 1762 "lexer.c"
yy328:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 260 "../snl.re"
	{ TYPEWORD(UINT32T,	"uint32_t"); }
#line 1770 "lexer.c"
yy330:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy53;
	}
#line 251 "../snl.re"
	{ TYPEWORD(UNSIGNED,	"unsigned"); }
#line 1778 "lexer.c"
}
#line 316 "../snl.re"


string_const:

#line 1785 "lexer.c"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128,   0, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy334;
	}
	if (yych <= '\n') goto yy337;
	if (yych <= '"') goto yy339;
	goto yy341;
yy334:
	yyaccept = 0;
	YYMARKER = ++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy334;
	}
	if (yych >= '#') goto yy342;
yy336:
#line 321 "../snl.re"
	{ goto string_const; }
#line 1843 "lexer.c"
yy337:
	++YYCURSOR;
yy338:
#line 326 "../snl.re"
	{ scan_report(s, "invalid character in string constant\n"); DONE; }
#line 1849 "lexer.c"
yy339:
	++YYCURSOR;
#line 322 "../snl.re"
	{
				s->end = cursor - 1;
				goto string_cat;
			}
#line 1857 "lexer.c"
yy341:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'b') {
		if (yych <= '7') {
			if (yych <= '&') {
				if (yych == '"') goto yy334;
				goto yy338;
			} else {
				if (yych <= '\'') goto yy334;
				if (yych <= '/') goto yy338;
				goto yy334;
			}
		} else {
			if (yych <= '[') {
				if (yych == '?') goto yy334;
				goto yy338;
			} else {
				if (yych <= '\\') goto yy334;
				if (yych <= '`') goto yy338;
				goto yy334;
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'm') {
				if (yych == 'f') goto yy334;
				goto yy338;
			} else {
				if (yych <= 'n') goto yy334;
				if (yych <= 'q') goto yy338;
				goto yy334;
			}
		} else {
			if (yych <= 'u') {
				if (yych == 't') goto yy334;
				goto yy338;
			} else {
				if (yych <= 'v') goto yy334;
				if (yych == 'x') goto yy344;
				goto yy338;
			}
		}
	}
yy342:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'b') {
		if (yych <= '7') {
			if (yych <= '&') {
				if (yych == '"') goto yy334;
			} else {
				if (yych <= '\'') goto yy334;
				if (yych >= '0') goto yy334;
			}
		} else {
			if (yych <= '[') {
				if (yych == '?') goto yy334;
			} else {
				if (yych <= '\\') goto yy334;
				if (yych >= 'a') goto yy334;
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'm') {
				if (yych == 'f') goto yy334;
			} else {
				if (yych <= 'n') goto yy334;
				if (yych >= 'r') goto yy334;
			}
		} else {
			if (yych <= 'u') {
				if (yych == 't') goto yy334;
			} else {
				if (yych <= 'v') goto yy334;
				if (yych == 'x') goto yy344;
			}
		}
	}
yy343:
	YYCURSOR = YYMARKER;
	if (yyaccept == 0) {
		goto yy336;
	} else {
		goto yy338;
	}
yy344:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy343;
		if (yych <= '9') goto yy334;
		goto yy343;
	} else {
		if (yych <= 'F') goto yy334;
		if (yych <= '`') goto yy343;
		if (yych <= 'f') goto yy334;
		goto yy343;
	}
}
#line 327 "../snl.re"


string_cat:

#line 1966 "lexer.c"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy349;
	}
	if (yych <= 0x08) goto yy347;
	if (yych <= '\n') goto yy352;
	if (yych == '"') goto yy354;
yy347:
	++YYCURSOR;
#line 346 "../snl.re"
	{
				cursor -= 1;
				LITERAL(STRCON, string_literal, strdupft(s->tok, s->end));
			}
#line 2018 "lexer.c"
yy349:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy349;
	}
#line 331 "../snl.re"
	{ goto string_cat; }
#line 2028 "lexer.c"
yy352:
	++YYCURSOR;
#line 332 "../snl.re"
	{
				if (cursor == s->eof) {
					cursor -= 1;
					LITERAL(STRCON, string_literal, strdupft(s->tok, s->end));
				}
				s->line++;
				goto string_cat;
			}
#line 2040 "lexer.c"
yy354:
	++YYCURSOR;
#line 340 "../snl.re"
	{
				uint len = s->end - s->tok;
				memmove(cursor - len, s->tok, len);
				s->tok = cursor - len;
				goto string_const;
			}
#line 2050 "lexer.c"
}
#line 350 "../snl.re"


line_marker:

#line 2057 "lexer.c"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		 64,  64,  64,  64,  64,  64,  64,  64, 
		 64,  64,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 64) {
		goto yy360;
	}
	++YYCURSOR;
#line 359 "../snl.re"
	{ goto line_marker_skip; }
#line 2102 "lexer.c"
yy360:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy363;
	}
	if (yych <= '/') goto yy362;
	if (yych <= '9') goto yy360;
yy362:
#line 354 "../snl.re"
	{
				s->line = atoi((char*)(s->tok + line_marker_part)) - 1;
				line_marker_part = cursor - s->tok;
				goto line_marker_str;
			}
#line 2119 "lexer.c"
yy363:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy363;
	}
	goto yy362;
}
#line 360 "../snl.re"


line_marker_str:

#line 2134 "lexer.c"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128,   0, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yych == '\n') goto yy369;
	if (yych == '"') goto yy371;
	++YYCURSOR;
yy368:
#line 373 "../snl.re"
	{ goto line_marker_skip; }
#line 2179 "lexer.c"
yy369:
	++YYCURSOR;
#line 369 "../snl.re"
	{
				cursor -= 1;
				goto line_marker_skip;
			}
#line 2187 "lexer.c"
yy371:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '\n') goto yy368;
	goto yy373;
yy372:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy373:
	if (yybm[0+yych] & 128) {
		goto yy372;
	}
	if (yych <= '\n') goto yy374;
	if (yych <= '"') goto yy375;
	goto yy377;
yy374:
	YYCURSOR = YYMARKER;
	goto yy368;
yy375:
	++YYCURSOR;
#line 365 "../snl.re"
	{
				s->file = strdupft(s->tok + line_marker_part + 1, cursor-1);
				goto line_marker_skip;
			}
#line 2213 "lexer.c"
yy377:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'b') {
		if (yych <= '7') {
			if (yych <= '&') {
				if (yych == '"') goto yy372;
				goto yy374;
			} else {
				if (yych <= '\'') goto yy372;
				if (yych <= '/') goto yy374;
				goto yy372;
			}
		} else {
			if (yych <= '[') {
				if (yych == '?') goto yy372;
				goto yy374;
			} else {
				if (yych <= '\\') goto yy372;
				if (yych <= '`') goto yy374;
				goto yy372;
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'm') {
				if (yych == 'f') goto yy372;
				goto yy374;
			} else {
				if (yych <= 'n') goto yy372;
				if (yych <= 'q') goto yy374;
				goto yy372;
			}
		} else {
			if (yych <= 'u') {
				if (yych == 't') goto yy372;
				goto yy374;
			} else {
				if (yych <= 'v') goto yy372;
				if (yych != 'x') goto yy374;
			}
		}
	}
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy374;
		if (yych <= '9') goto yy372;
		goto yy374;
	} else {
		if (yych <= 'F') goto yy372;
		if (yych <= '`') goto yy374;
		if (yych <= 'f') goto yy372;
		goto yy374;
	}
}
#line 374 "../snl.re"


line_marker_skip:

#line 2277 "lexer.c"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy381;
	}
	goto yy384;
yy381:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy381;
	}
#line 378 "../snl.re"
	{ goto snl; }
#line 2329 "lexer.c"
yy384:
	++YYCURSOR;
#line 379 "../snl.re"
	{ cursor -= 1; goto snl; }
#line 2334 "lexer.c"
}
#line 380 "../snl.re"


comment:

#line 2341 "lexer.c"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yych == '\n') goto yy390;
	if (yych == '*') goto yy392;
	++YYCURSOR;
yy389:
#line 385 "../snl.re"
	{ goto comment; }
#line 2352 "lexer.c"
yy390:
	++YYCURSOR;
#line 386 "../snl.re"
	{
				if (cursor == s->eof) {
					scan_report(s, "at eof: unterminated comment\n");
					DONE;
				}
				s->tok = cursor;
				s->line++;
				goto comment;
			}
#line 2365 "lexer.c"
yy392:
	yych = *++YYCURSOR;
	if (yych != '/') goto yy389;
	++YYCURSOR;
#line 384 "../snl.re"
	{ goto snl; }
#line 2372 "lexer.c"
}
#line 395 "../snl.re"


c_code:

#line 2379 "lexer.c"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
	yych = *YYCURSOR;
	if (yych <= ' ') {
		if (yych <= '\t') {
			if (yych >= '\t') goto yy399;
		} else {
			if (yych <= '\n') goto yy400;
			if (yych >= ' ') goto yy399;
		}
	} else {
		if (yych <= '#') {
			if (yych >= '#') goto yy402;
		} else {
			if (yych == '}') goto yy403;
		}
	}
	++YYCURSOR;
yy398:
#line 405 "../snl.re"
	{ goto c_code; }
#line 2437 "lexer.c"
yy399:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 128) {
		goto yy404;
	}
	if (yych == '#') goto yy407;
	goto yy398;
yy400:
	++YYCURSOR;
#line 410 "../snl.re"
	{
				if (cursor == s->eof) {
					scan_report(s, "at eof: unterminated literal c-code section\n");
					DONE;
				}
				s->line++;
				goto c_code;
			}
#line 2457 "lexer.c"
yy402:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy408;
		goto yy398;
	} else {
		if (yych <= ' ') goto yy408;
		if (yych == 'l') goto yy411;
		goto yy398;
	}
yy403:
	yych = *++YYCURSOR;
	if (yych == '%') goto yy412;
	goto yy398;
yy404:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 6) YYFILL(6);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy404;
	}
	if (yych == '#') goto yy407;
yy406:
	YYCURSOR = YYMARKER;
	if (yyaccept == 0) {
		goto yy398;
	} else {
		goto yy410;
	}
yy407:
	yych = *++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych != '\t') goto yy406;
	} else {
		if (yych <= ' ') goto yy408;
		if (yych == 'l') goto yy411;
		goto yy406;
	}
yy408:
	yyaccept = 1;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy408;
	} else {
		if (yych <= ' ') goto yy408;
		if (yych == 'l') goto yy411;
	}
yy410:
#line 406 "../snl.re"
	{
				line_marker_part = cursor - s->tok;
				goto line_marker;
			}
#line 2514 "lexer.c"
yy411:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy414;
	goto yy406;
yy412:
	++YYCURSOR;
#line 399 "../snl.re"
	{
#ifdef DEBUG
				report("c_code: tok=%p", s->tok);
#endif
				LITERAL(CCODE, embedded_c_code, strdupft(s->tok, cursor - 2));
			}
#line 2528 "lexer.c"
yy414:
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy406;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy406;
	yych = *++YYCURSOR;
	if (yych == '\t') goto yy417;
	if (yych != ' ') goto yy406;
yy417:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych == '\t') goto yy417;
	if (yych == ' ') goto yy417;
	goto yy410;
}
#line 418 "../snl.re"


c_code_line:

#line 2550 "lexer.c"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yych <= '\n') {
		if (yych <= 0x08) goto yy421;
		if (yych <= '\t') goto yy423;
		goto yy424;
	} else {
		if (yych == ' ') goto yy423;
	}
yy421:
	++YYCURSOR;
yy422:
#line 422 "../snl.re"
	{
				s->end = cursor;
				goto c_code_line;
			}
#line 2604 "lexer.c"
yy423:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x08) goto yy422;
	if (yych <= '\n') goto yy427;
	if (yych == ' ') goto yy427;
	goto yy422;
yy424:
	++YYCURSOR;
#line 426 "../snl.re"
	{
				if (cursor == s->eof) {
					cursor -= 1;
				}
				s->line++;
				if (s->end > s->tok) {
					LITERAL(CCODE, embedded_c_code, strdupft(s->tok, s->end));
				}
				goto snl;
			}
#line 2624 "lexer.c"
yy426:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy427:
	if (yybm[0+yych] & 128) {
		goto yy426;
	}
	if (yych <= 0x08) goto yy428;
	if (yych <= '\n') goto yy424;
yy428:
	YYCURSOR = YYMARKER;
	goto yy422;
}
#line 436 "../snl.re"

	DONE;		/* dead code, only here to make compiler warning go away */
}

#ifdef TEST_LEXER
void report_loc(const char *f, int l) {
	fprintf(stderr, "%s:%d: ", f, l);
}

int main() {
	Scanner s;
	int		tt;	/* token type */
	Token		tv;	/* token value */

	memset(&s, 0, sizeof(s));

	s.cur = fill(&s, s.cur);
	s.line = 1;

	while( (tt = scan(&s, &tv)) != EOI) {
		printf("%s:%d: %2d\t$%s$\n", tv.file, tv.line, tt, tv.str);
	}
	return 0;
}
#else

Expr *parse_program(const char *src_file)
{
	Scanner	s;
	int	tt;		/* token type */
	Token	tv;		/* token value */
	Expr	*result;	/* result of parsing */
	void	*parser;	/* the (lemon generated) parser */

	memset(&s, 0, sizeof(s));
	s.file = src_file;
	s.line = 1;

	parser = snlParserAlloc(malloc);
	do
	{
		tt = scan(&s, &tv);
#ifdef	DEBUG
		report_at(tv.file, tv.line, "%2d\t$%s$\n", tt, tv.str);
#endif
		snlParser(parser, tt, tv, &result);
	}
	while (tt);
	snlParserFree(parser, free);
	return result;
}

#endif /* TEST_LEXER */
